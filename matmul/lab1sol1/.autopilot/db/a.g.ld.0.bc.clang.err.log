remark: C:/Xilinx/Vitis_HLS/2022.2/common/technology/autopilot\ap_int_base.h:214:67: Inlining function 'ssdm_int<32, false>::ssdm_int(unsigned int)' into 'ap_int_base<32, false>::ap_int_base(int)'
remark: <unknown>:0:0: Inlining function 'ap_int_base<32, false>::ap_int_base(int)' into 'ap_uint<32>::ap_uint(int)'
remark: C:/Xilinx/Vitis_HLS/2022.2/common/technology/autopilot\ap_int_base.h:185:106: Inlining function 'ssdm_int<16, false>::ssdm_int(unsigned short)' into 'ap_int_base<16, false>::ap_int_base<8, false>(ap_int_base<8, false> const&)'
remark: C:/Xilinx/Vitis_HLS/2022.2/common/technology/autopilot\ap_int_base.h:214:67: Inlining function 'ssdm_int<16, false>::ssdm_int(unsigned short)' into 'ap_int_base<16, false>::ap_int_base(int)'
remark: C:/Xilinx/Vitis_HLS/2022.2/common/technology/autopilot\ap_int_base.h:1494:339: Inlining function 'ap_int_base<16, false>::ap_int_base<8, false>(ap_int_base<8, false> const&)' into 'ap_int_base<8, false>::RType<8, false>::mult operator*<8, false, 8, false>(ap_int_base<8, false> const&, ap_int_base<8, false> const&)'
remark: C:/Xilinx/Vitis_HLS/2022.2/common/technology/autopilot\ap_int_base.h:1494:516: Inlining function 'ap_int_base<16, false>::ap_int_base(int)' into 'ap_int_base<8, false>::RType<8, false>::mult operator*<8, false, 8, false>(ap_int_base<8, false> const&, ap_int_base<8, false> const&)'
remark: C:/Xilinx/Vitis_HLS/2022.2/common/technology/autopilot\ap_int_base.h:1494:427: Inlining function 'ap_int_base<16, false>::ap_int_base<8, false>(ap_int_base<8, false> const&)' into 'ap_int_base<8, false>::RType<8, false>::mult operator*<8, false, 8, false>(ap_int_base<8, false> const&, ap_int_base<8, false> const&)'
remark: matmul.cpp:35:12: Inlining function 'ap_int_base<32, false>& ap_int_base<32, false>::operator+=<16, false>(ap_int_base<16, false> const&)' into 'mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*)'
remark: matmul.cpp:35:35: Inlining function 'ap_int_base<8, false>::RType<8, false>::mult operator*<8, false, 8, false>(ap_int_base<8, false> const&, ap_int_base<8, false> const&)' into 'mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*)'
remark: matmul.cpp:17:22: Sequential read of length 32 has been inferred _XLX_SEP_ OldID=for.inc.load.7,  _XLX_SEP_ in1seq in1 gmem VITIS_LOOP_17_1 matmul.cpp:17:22 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:24:22: Sequential read of length 64 has been inferred _XLX_SEP_ OldID=for.inc46.load.7,  _XLX_SEP_ in2seq in2 gmem VITIS_LOOP_24_3 matmul.cpp:24:22 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:42:22: Sequential write of length 128 has been inferred _XLX_SEP_ OldID=for.inc105.store.8,  _XLX_SEP_ out_rseq out_r gmem VITIS_LOOP_42_8 matmul.cpp:42:22 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:42:22: Could not widen since type i32 size is greater than or equal to the max_widen_bitwidth threshold of 0 _XLX_SEP_ out_rseq out_r gmem VITIS_LOOP_43_9 matmul.cpp:43:23 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:24:22: Could not widen since type i8 size is greater than or equal to the max_widen_bitwidth threshold of 0 _XLX_SEP_ in2seq in2 gmem VITIS_LOOP_25_4 matmul.cpp:25:23 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:17:22: Could not widen since type i8 size is greater than or equal to the max_widen_bitwidth threshold of 0 _XLX_SEP_ in1seq in1 gmem VITIS_LOOP_18_2 matmul.cpp:18:23 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:17:22: Inferred burst reverted due to burst accesses data width is different from m_axi port width _XLX_SEP_ in1seq  in1 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:24:22: Inferred burst reverted due to burst accesses data width is different from m_axi port width _XLX_SEP_ in2seq  in2 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:42:22: Multiple burst writes of length 128 and bit width 32 has been inferred. These burst requests might be further partitioned into multiple requests during RTL generation, based on max_read_burst_length or max_write_burst_length settings. _XLX_SEP_ seq  gmem VITIS_LOOP_42_8 matmul.cpp:42:22 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:42:22: Multiple burst writes of length 128 and bit width 32 in loop 'VITIS_LOOP_42_8'(matmul.cpp:42:22) has been inferred on bundle 'gmem'. These burst requests might be further partitioned into multiple requests during RTL generation, based on max_read_burst_length or max_write_burst_length settings.
