remark: C:/Xilinx/Vitis_HLS/2022.2/common/technology/autopilot\ap_int_base.h:214:67: Inlining function 'ssdm_int<32, false>::ssdm_int(unsigned int)' into 'ap_int_base<32, false>::ap_int_base(int)'
remark: <unknown>:0:0: Inlining function 'ap_int_base<32, false>::ap_int_base(int)' into 'ap_uint<32>::ap_uint(int)'
remark: C:/Xilinx/Vitis_HLS/2022.2/common/technology/autopilot\ap_int_base.h:185:106: Inlining function 'ssdm_int<16, false>::ssdm_int(unsigned short)' into 'ap_int_base<16, false>::ap_int_base<8, false>(ap_int_base<8, false> const&)'
remark: C:/Xilinx/Vitis_HLS/2022.2/common/technology/autopilot\ap_int_base.h:214:67: Inlining function 'ssdm_int<16, false>::ssdm_int(unsigned short)' into 'ap_int_base<16, false>::ap_int_base(int)'
remark: C:/Xilinx/Vitis_HLS/2022.2/common/technology/autopilot\ap_int_base.h:1494:339: Inlining function 'ap_int_base<16, false>::ap_int_base<8, false>(ap_int_base<8, false> const&)' into 'ap_int_base<8, false>::RType<8, false>::mult operator*<8, false, 8, false>(ap_int_base<8, false> const&, ap_int_base<8, false> const&)'
remark: C:/Xilinx/Vitis_HLS/2022.2/common/technology/autopilot\ap_int_base.h:1494:516: Inlining function 'ap_int_base<16, false>::ap_int_base(int)' into 'ap_int_base<8, false>::RType<8, false>::mult operator*<8, false, 8, false>(ap_int_base<8, false> const&, ap_int_base<8, false> const&)'
remark: C:/Xilinx/Vitis_HLS/2022.2/common/technology/autopilot\ap_int_base.h:1494:427: Inlining function 'ap_int_base<16, false>::ap_int_base<8, false>(ap_int_base<8, false> const&)' into 'ap_int_base<8, false>::RType<8, false>::mult operator*<8, false, 8, false>(ap_int_base<8, false> const&, ap_int_base<8, false> const&)'
remark: matmul.cpp:52:17: Inlining function 'ap_int_base<32, false>& ap_int_base<32, false>::operator+=<16, false>(ap_int_base<16, false> const&)' into 'mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*)'
remark: matmul.cpp:52:40: Inlining function 'ap_int_base<8, false>::RType<8, false>::mult operator*<8, false, 8, false>(ap_int_base<8, false> const&, ap_int_base<8, false> const&)' into 'mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*)'
remark: matmul.cpp:13:13: Applying array_partition to 'A': Cyclic partitioning with factor 16 on dimension 1.
remark: matmul.cpp:14:16: Applying array_partition to 'B': Block partitioning with factor 16 on dimension 1.
remark: matmul.cpp:25:6: Sequential read of length 4096 has been inferred _XLX_SEP_ OldID=for.body.load.34,  _XLX_SEP_ in1seq in1 gmem0 readA matmul.cpp:25:6 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:36:3: Sequential read of length 4096 has been inferred _XLX_SEP_ OldID=for.inc31.load.22,  _XLX_SEP_ in2seq in2 gmem readB matmul.cpp:36:3 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:60:6: Sequential write of length 4096 has been inferred _XLX_SEP_ OldID=for.inc78.store.6,  _XLX_SEP_ out_rseq out_r gmem0 writeC matmul.cpp:60:6 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:60:6: Could not widen since type i32 size is greater than or equal to alignment 1(bytes) _XLX_SEP_ out_rseq out_r gmem0 writeC matmul.cpp:60:6 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:36:3: Could not widen since type i8 size is greater than or equal to alignment 1(bytes) _XLX_SEP_ in2seq in2 gmem readB matmul.cpp:36:3 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:25:6: Could not widen since type i8 size is greater than or equal to alignment 1(bytes) _XLX_SEP_ in1seq in1 gmem0 readA matmul.cpp:25:6 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:25:6: Inferred burst reverted due to burst accesses data width is different from m_axi port width _XLX_SEP_ in1seq  in1 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:36:3: Multiple burst reads of length 4096 and bit width 8 has been inferred. These burst requests might be further partitioned into multiple requests during RTL generation, based on max_read_burst_length or max_write_burst_length settings. _XLX_SEP_ seq  gmem readB matmul.cpp:36:3 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:36:3: Multiple burst reads of length 4096 and bit width 8 in loop 'readB'(matmul.cpp:36:3) has been inferred on bundle 'gmem'. These burst requests might be further partitioned into multiple requests during RTL generation, based on max_read_burst_length or max_write_burst_length settings.
remark: matmul.cpp:60:6: Multiple burst writes of length 4096 and bit width 32 has been inferred. These burst requests might be further partitioned into multiple requests during RTL generation, based on max_read_burst_length or max_write_burst_length settings. _XLX_SEP_ seq1  gmem0 writeC matmul.cpp:60:6 mult_hw(ap_uint<8>*, ap_uint<8>*, ap_uint<32>*) 
remark: matmul.cpp:60:6: Multiple burst writes of length 4096 and bit width 32 in loop 'writeC'(matmul.cpp:60:6) has been inferred on bundle 'gmem0'. These burst requests might be further partitioned into multiple requests during RTL generation, based on max_read_burst_length or max_write_burst_length settings.
